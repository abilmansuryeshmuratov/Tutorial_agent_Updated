import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';

// Hoist mock creation to ensure it's available before vi.mock
const { mockGenerateText, coreMock } = vi.hoisted(() => {
    const mockGenerateText = vi.fn();
    mockGenerateText.mockImplementation(async () => 'Generated response based on context');
    
    // Import core mock inside hoisted function
    const coreMock = {
        elizaLogger: {
            log: vi.fn(),
            error: vi.fn(),
            warn: vi.fn(),
            info: vi.fn(),
            debug: vi.fn()
        },
        generateMessageResponse: vi.fn().mockResolvedValue({
            text: 'Generated response',
            content: { text: 'Generated response' },
            action: null
        }),
        generateShouldRespond: vi.fn().mockResolvedValue('RESPOND'),
        composeContext: vi.fn().mockReturnValue('Composed context'),
        stringToUuid: vi.fn(str => `uuid-${str}`),
        getEmbeddingZeroVector: vi.fn(() => Array(1536).fill(0)),
        extractAttributes: vi.fn((text, attrs) => {
            const result: any = {};
            attrs.forEach(attr => {
                result[attr] = null;
            });
            return result;
        }),
        cleanJsonResponse: vi.fn(text => text.trim()),
        parseJSONObjectFromText: vi.fn(text => {
            try {
                return JSON.parse(text);
            } catch {
                return null;
            }
        }),
        truncateToCompleteSentence: vi.fn((text, length) => {
            if (text.length <= length) return text;
            return text.substring(0, length - 3) + '...';
        }),
        messageCompletionFooter: 'Response generated by AI assistant.'
    };
    
    return { mockGenerateText, coreMock };
});

// Mock dependencies - must be before other imports
vi.mock('@elizaos/core', () => ({
    ...coreMock,
    generateText: mockGenerateText,
    generateMessageResponse: coreMock.generateMessageResponse,
    ModelClass: {
        SMALL: 'small',
        MEDIUM: 'medium',
        LARGE: 'large'
    },
    ServiceType: {
        IMAGE_DESCRIPTION: 'IMAGE_DESCRIPTION'
    },
    HandlerCallback: vi.fn()
}));

// Mock the utils module to control wait() and other utilities
vi.mock('@elizaos/client-twitter/src/utils', () => ({
    buildConversationThread: vi.fn().mockResolvedValue(undefined),
    sendTweet: vi.fn().mockResolvedValue([{
        id: 'response-msg-id',
        content: { text: 'Response sent', source: 'twitter' },
        userId: 'agent-123',
        roomId: 'room-123',
        createdAt: Date.now()
    }]),
    wait: vi.fn().mockResolvedValue(undefined),
    fetchMediaData: vi.fn().mockResolvedValue(null)
}));

import { 
    mockGenerateMessageResponse, 
    mockGenerateShouldRespond,
    mockComposeContext,
    mockStringToUuid,
    mockGetEmbeddingZeroVector,
    resetAllMocks 
} from './mocks/core.mock';

import { TwitterSearchClient } from '@elizaos/client-twitter/src/search';
import { IAgentRuntime, ModelClass } from '@elizaos/core';
import { SearchMode } from 'agent-twitter-client';
import { 
    mockTweets, 
    mockApiResponses, 
    createMockTweet,
    createMockApiResponse,
    mockTimeline 
} from './mocks/twitter-api-v2.mock';

describe('Twitter Search Validation Tests', () => {
    let searchClient: TwitterSearchClient;
    let mockClient: any;
    let runtime: IAgentRuntime;
    const elizaLogger = coreMock.elizaLogger;

    beforeEach(() => {
        vi.clearAllMocks();
        mockGenerateText.mockClear();
        // Reset all core mocks
        Object.values(coreMock).forEach(mock => {
            if (typeof mock === 'function' && 'mockClear' in mock) {
                mock.mockClear();
            } else if (typeof mock === 'object') {
                Object.values(mock).forEach(innerMock => {
                    if (typeof innerMock === 'function' && 'mockClear' in innerMock) {
                        innerMock.mockClear();
                    }
                });
            }
        });
        vi.useFakeTimers(); // Use fake timers to control delays

        // Mock Twitter client
        mockClient = {
            profile: {
                id: '123456789',
                username: 'testbot',
                screenName: 'Test Bot'
            },
            twitterConfig: {
                TWITTER_USERNAME: 'testbot',
                TWITTER_DRY_RUN: false
            },
            twitterClient: {
                getTweet: vi.fn(),
                sendTweet: vi.fn()
            },
            fetchSearchTweets: vi.fn(),
            fetchHomeTimeline: vi.fn(),
            cacheTimeline: vi.fn(),
            cacheTweet: vi.fn(),
            saveRequestMessage: vi.fn(),
            requestQueue: {
                add: vi.fn().mockImplementation(async (fn) => fn())
            }
        };

        // Mock runtime
        runtime = {
            agentId: 'agent-123',
            character: {
                name: 'TestBot',
                bio: 'A test bot for Twitter search',
                topics: ['artificial intelligence', 'machine learning', 'technology'],
                templates: {}
            },
            messageManager: {
                createMemory: vi.fn().mockResolvedValue({}),
                getMemoryById: vi.fn().mockResolvedValue(null),
                getMemoriesByRoomIds: vi.fn().mockResolvedValue([])
            },
            ensureConnection: vi.fn(),
            ensureUserExists: vi.fn(),
            ensureRoomExists: vi.fn(),
            ensureParticipantInRoom: vi.fn(),
            composeState: vi.fn().mockResolvedValue({
                userId: 'agent-123',
                roomId: 'room-123',
                agentId: 'agent-123',
                content: { text: '', action: '' }
            }),
            updateRecentMessageState: vi.fn(state => state),
            processActions: vi.fn(),
            evaluate: vi.fn(),
            cacheManager: {
                get: vi.fn(),
                set: vi.fn()
            },
            getService: vi.fn().mockReturnValue({
                describeImage: vi.fn().mockResolvedValue('An image description')
            })
        } as any;

        searchClient = new TwitterSearchClient(mockClient, runtime);
        
        // Mock the engageWithSearchTermsLoop to prevent infinite recursion
        vi.spyOn(searchClient as any, 'engageWithSearchTermsLoop').mockImplementation(async () => {
            // Just call engageWithSearchTerms once without scheduling next
            return (searchClient as any).engageWithSearchTerms();
        });
    });

    afterEach(() => {
        vi.clearAllTimers();
        vi.clearAllMocks();
        vi.useRealTimers();
    });

    describe('Search Initialization and Configuration', () => {
        it('should initialize with correct configuration', () => {
            expect(searchClient).toBeDefined();
            expect(searchClient['twitterUsername']).toBe('testbot');
        });

        it('should start search loop with random intervals', async () => {
            const startSpy = vi.spyOn(searchClient, 'start');
            // Mock the private method to prevent infinite loop
            const loopSpy = vi.spyOn(searchClient as any, 'engageWithSearchTermsLoop');
            loopSpy.mockImplementation(() => {
                // Just call engageWithSearchTerms once without scheduling next
                return (searchClient as any).engageWithSearchTerms();
            });
            
            await searchClient.start();
            
            expect(startSpy).toHaveBeenCalled();
            expect(loopSpy).toHaveBeenCalled();
        });
    });

    describe('Search Query Execution', () => {
        it('should search using character topics', async () => {
            const searchResults = [
                createMockTweet({ id: '1', text: 'AI breakthrough announced today!' }),
                createMockTweet({ id: '2', text: 'Machine learning models getting smarter' })
            ];

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: searchResults
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce(mockTimeline);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('1'); // Select first tweet
            mockGenerateMessageResponse.mockResolvedValueOnce({
                text: 'Exciting developments!',
                action: null
            });

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            // Should use one of the topics
            expect(mockClient.fetchSearchTweets).toHaveBeenCalledWith(
                expect.stringMatching(/artificial intelligence|machine learning|technology/),
                20,
                SearchMode.Top
            );
        });

        it('should handle empty search results', async () => {
            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: []
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(elizaLogger.log).toHaveBeenCalledWith(
                expect.stringContaining('No valid tweets found'),
                expect.any(String)
            );
        });

        it('should validate search API response structure', async () => {
            const apiResponse = mockApiResponses.searchTweets.success;
            const tweets = apiResponse.data.map((t: any) => createMockTweet(t));

            mockClient.fetchSearchTweets.mockResolvedValueOnce({ tweets });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce(tweets[0].id);

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(tweets).toHaveLength(3);
            expect(tweets[0]).toHaveProperty('id');
            expect(tweets[0]).toHaveProperty('text');
        });
    });

    describe('Tweet Selection and Filtering', () => {
        it('should select most interesting tweet from search results', async () => {
            const tweets = [
                createMockTweet({ 
                    id: '1', 
                    text: 'Just posted a cat picture #cute',
                    hashtags: ['#cute']
                }),
                createMockTweet({ 
                    id: '2', 
                    text: 'Fascinating insights on AI safety and alignment'
                }),
                createMockTweet({ 
                    id: '3', 
                    text: 'RT: Check out this link spam.com'
                })
            ];

            mockClient.fetchSearchTweets.mockResolvedValueOnce({ tweets });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('2'); // Select the AI tweet
            mockGenerateMessageResponse.mockResolvedValueOnce({
                text: 'Great insights on AI safety!',
                action: null
            });

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(mockGenerateText).toHaveBeenCalledWith({
                runtime,
                context: expect.stringContaining('Which tweet is the most interesting'),
                modelClass: ModelClass.SMALL
            });
        });

        it('should filter out bot\'s own tweets from threads', async () => {
            const tweetWithBotInThread = createMockTweet({
                id: '4',
                text: 'Interesting discussion',
                thread: [
                    createMockTweet({ id: '4a', username: 'user1' }),
                    createMockTweet({ id: '4b', username: 'testbot' }), // Bot's tweet
                    createMockTweet({ id: '4c', username: 'user2' })
                ]
            });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [tweetWithBotInThread]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('5'); // Try to select filtered tweet

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            // Tweet should be filtered out, so no response generated
            expect(elizaLogger.warn).toHaveBeenCalledWith(
                'No matching tweet found for the selected ID'
            );
        });

        it('should skip tweets from bot itself', async () => {
            const ownTweet = createMockTweet({
                id: '5',
                text: 'My own tweet',
                username: 'testbot',
                userId: '123456789'
            });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [ownTweet]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('5');

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(elizaLogger.log).toHaveBeenCalledWith(
                'Skipping tweet from bot itself'
            );
        });
    });

    describe('Response Generation with Context', () => {
        it('should generate response with timeline context', async () => {
            const searchTweet = createMockTweet({
                id: '6',
                text: 'What are your thoughts on AGI?'
            });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [searchTweet]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce(mockTimeline);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('6');
            coreMock.generateMessageResponse.mockResolvedValueOnce({
                text: 'AGI development requires careful consideration.',
                action: null
            });
            
            // Mock the send tweet flow
            // requestQueue.add is already mocked in mockClient setup
            mockClient.twitterClient.sendTweet.mockResolvedValueOnce({
                json: vi.fn().mockResolvedValue({
                    data: {
                        create_tweet: {
                            tweet_results: {
                                result: {
                                    rest_id: "1234567890",
                                    legacy: {
                                        full_text: "AGI development requires careful consideration.",
                                        created_at: new Date().toISOString()
                                    }
                                }
                            }
                        }
                    }
                })
            });

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(runtime.composeState).toHaveBeenCalledWith(
                expect.any(Object),
                expect.objectContaining({
                    timeline: expect.stringContaining("TestBot's Home Timeline")
                })
            );
        });

        it('should handle retweets with original context', async () => {
            const retweet = createMockTweet({
                id: '7',
                text: 'RT @original: Great article on AI',
                isRetweet: true
            });

            const originalTweet = createMockTweet({
                id: '7a',
                text: 'Great article on AI: link.com',
                username: 'original'
            });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [retweet]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);
            mockClient.twitterClient.getTweet.mockResolvedValueOnce(originalTweet);

            mockGenerateText.mockResolvedValueOnce('7');
            mockGenerateMessageResponse.mockResolvedValueOnce({
                text: 'Thanks for sharing this article!',
                action: null
            });

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(mockClient.requestQueue.add).toHaveBeenCalled();
            expect(runtime.composeState).toHaveBeenCalledWith(
                expect.any(Object),
                expect.objectContaining({
                    tweetContext: expect.stringContaining('Retweeting @original')
                })
            );
        });

        it('should process images in search results', async () => {
            const tweetWithImage = createMockTweet({
                id: '8',
                text: 'Check out this AI visualization',
                photos: [
                    { url: 'https://example.com/ai-viz.jpg', alt_text: 'AI visualization' }
                ]
            });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [tweetWithImage]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('8');
            mockGenerateMessageResponse.mockResolvedValueOnce({
                text: 'Fascinating visualization!',
                action: null
            });

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(runtime.getService).toHaveBeenCalledWith('IMAGE_DESCRIPTION');
            expect(runtime.composeState).toHaveBeenCalledWith(
                expect.any(Object),
                expect.objectContaining({
                    tweetContext: expect.stringContaining('Images in Post (Described)')
                })
            );
        });
    });

    describe('Reply Handling and Validation', () => {
        it('should include reply context in response', async () => {
            const tweetWithReplies = createMockTweet({
                id: '9',
                text: 'What do you think about this?',
                thread: [
                    createMockTweet({ 
                        id: '9a', 
                        text: 'I think it\'s interesting',
                        username: 'user1'
                    }),
                    createMockTweet({ 
                        id: '9b', 
                        text: 'Agreed, very compelling',
                        username: 'user2'
                    })
                ]
            });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [tweetWithReplies]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('9');
            mockGenerateMessageResponse.mockResolvedValueOnce({
                text: 'I share similar thoughts!',
                action: null
            });

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(runtime.composeState).toHaveBeenCalledWith(
                expect.any(Object),
                expect.objectContaining({
                    tweetContext: expect.stringContaining('Replies to original post')
                })
            );
        });

        it('should validate response length constraints', async () => {
            const tweet = createMockTweet({
                id: '10',
                text: 'Short question?'
            });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [tweet]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('10');
            
            // Long response that should be constrained
            mockGenerateMessageResponse.mockResolvedValueOnce({
                text: 'This is a very long response that exceeds the 20 word limit specified in the template',
                action: null
            });

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            // Template specifies max 20 words - check that context was composed with proper template
            expect(coreMock.composeContext).toHaveBeenCalledWith({
                state: expect.any(Object),
                template: expect.stringContaining('CANNOT be longer than 20 words')
            });
        });
    });

    describe('Memory and State Management', () => {
        it('should save tweet to memory after response', async () => {
            const tweet = createMockTweet({
                id: '11',
                text: 'Memory test tweet'
            });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [tweet]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('11');
            mockGenerateMessageResponse.mockResolvedValueOnce({
                text: 'Response saved to memory',
                action: null
            });

            mockClient.twitterClient.sendTweet.mockResolvedValueOnce(
                createMockApiResponse(mockApiResponses.createTweet.success)
            );

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            // The memory manager should be called once for the response
            expect(runtime.messageManager.createMemory).toHaveBeenCalledTimes(1);
            
            // Check that the response was saved as a memory
            expect(runtime.messageManager.createMemory).toHaveBeenCalledWith(
                expect.objectContaining({
                    content: expect.objectContaining({
                        text: 'Response sent',
                        source: 'twitter'
                    })
                }),
                false
            );
            
            // Check that the original tweet was saved via saveRequestMessage
            expect(mockClient.saveRequestMessage).toHaveBeenCalledWith(
                expect.objectContaining({
                    content: expect.objectContaining({
                        text: tweet.text,
                        url: tweet.permanentUrl
                    })
                }),
                expect.any(Object)
            );
        });

        it('should track responded tweets', async () => {
            const tweet = createMockTweet({ id: '12' });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [tweet]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('12');
            mockGenerateMessageResponse.mockResolvedValueOnce({
                text: 'Tracked response',
                action: null
            });

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(searchClient['respondedTweets'].has('12')).toBe(true);
        });

        it('should cache response generation context', async () => {
            const tweet = createMockTweet({ id: '13' });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [tweet]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('13');
            mockGenerateMessageResponse.mockResolvedValueOnce({
                text: 'Cached response',
                action: null
            });

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(runtime.cacheManager.set).toHaveBeenCalledWith(
                `twitter/tweet_generation_${tweet.id}.txt`,
                expect.stringContaining('Context:')
            );
        });
    });

    describe('Error Handling', () => {
        it('should handle search API errors', async () => {
            // Mock console.error since the source uses console.error not elizaLogger
            const consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
            
            mockClient.fetchSearchTweets.mockRejectedValueOnce(
                new Error('Search API error')
            );

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(consoleErrorSpy).toHaveBeenCalledWith(
                'Error engaging with search terms:',
                expect.any(Error)
            );
            
            consoleErrorSpy.mockRestore();
        });

        it('should handle tweet sending failures', async () => {
            // Mock console.error since the source uses console.error not elizaLogger
            const consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
            
            const tweet = createMockTweet({ id: '14' });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [tweet]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('14');
            mockGenerateMessageResponse.mockResolvedValueOnce({
                text: 'Failed response',
                action: null
            });

            // Mock sendTweet to throw error but ensure it's imported from the mocked module
            const utils = await vi.importMock('@elizaos/client-twitter/src/utils');
            vi.mocked(utils.sendTweet).mockRejectedValueOnce(new Error('Send failed'));

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(consoleErrorSpy).toHaveBeenCalledWith(
                expect.stringContaining('Error sending response post:')
            );
            
            consoleErrorSpy.mockRestore();
        });

        it('should handle missing response text', async () => {
            const tweet = createMockTweet({ id: '15' });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [tweet]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('15');
            coreMock.generateMessageResponse.mockResolvedValueOnce({
                text: '',
                action: null
            });

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(elizaLogger.warn).toHaveBeenCalledWith(
                'Returning: No response text found'
            );
        });
    });

    describe('URL and Link Handling', () => {
        it('should include URLs in tweet context', async () => {
            const tweetWithUrls = createMockTweet({
                id: '16',
                text: 'Check out this article',
                urls: ['https://example.com/article', 'https://example.com/resource']
            });

            mockClient.fetchSearchTweets.mockResolvedValueOnce({
                tweets: [tweetWithUrls]
            });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);

            mockGenerateText.mockResolvedValueOnce('16');
            mockGenerateMessageResponse.mockResolvedValueOnce({
                text: 'Great resources!',
                action: null
            });

            const promise = searchClient['engageWithSearchTerms']();
            
            // Advance timers to handle the 5-second delay
            await vi.advanceTimersByTimeAsync(5000);
            
            await promise;

            expect(runtime.composeState).toHaveBeenCalledWith(
                expect.any(Object),
                expect.objectContaining({
                    tweetContext: expect.stringContaining('URLs:')
                })
            );
        });
    });

    describe('Search Loop Timing', () => {
        it('should schedule next search with random delay', async () => {
            // Remove the spy for this specific test to test the actual loop
            vi.restoreAllMocks();
            searchClient = new TwitterSearchClient(mockClient, runtime);
            
            // Mock fetchSearchTweets to return empty to avoid processing
            mockClient.fetchSearchTweets.mockResolvedValueOnce({ tweets: [] });
            mockClient.fetchHomeTimeline.mockResolvedValueOnce([]);
            mockClient.cacheTimeline.mockResolvedValueOnce(undefined);
            
            // Start the loop
            searchClient['engageWithSearchTermsLoop']();
            
            // Let the first search complete
            await vi.advanceTimersByTimeAsync(5000);

            // Check that a timer was set
            expect(vi.getTimerCount()).toBeGreaterThanOrEqual(1);
            
            expect(elizaLogger.log).toHaveBeenCalledWith(
                expect.stringMatching(/Next twitter search scheduled in \d+ minutes/)
            );
        });
    });
});